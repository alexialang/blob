/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@angular/core@19.2.9/fesm2022/rxjs-interop.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{assertInInjectionContext as e,inject as n,DestroyRef as r,ɵgetOutputDestroyRef as t,Injector as o,effect as s,untracked as i,ɵmicrotaskEffect as u,assertNotInReactiveContext as c,signal as d,ɵRuntimeError as a,computed as l,PendingTasks as b,resource as v}from"@angular/core";import{Observable as p,ReplaySubject as f}from"rxjs";import{takeUntil as m}from"rxjs/operators";
/**
 * @license Angular v19.2.9
 * (c) 2010-2025 Google LLC. https://angular.io/
 * License: MIT
 */function y(t){t||(e(y),t=n(r));const o=new p((e=>t.onDestroy(e.next.bind(e))));return e=>e.pipe(m(o))}class g{source;destroyed=!1;destroyRef=n(r);constructor(e){this.source=e,this.destroyRef.onDestroy((()=>{this.destroyed=!0}))}subscribe(e){if(this.destroyed)throw new a(953,ngDevMode&&"Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");const n=this.source.pipe(y(this.destroyRef)).subscribe({next:n=>e(n)});return{unsubscribe:()=>n.unsubscribe()}}}function h(n,r){return ngDevMode&&e(h),new g(n)}function w(e){const n=t(e);return new p((r=>{n?.onDestroy((()=>r.complete()));const t=e.subscribe((e=>r.next(e)));return()=>t.unsubscribe()}))}function x(t,u){!u?.injector&&e(x);const c=u?.injector??n(o),d=new f(1),a=s((()=>{let e;try{e=t()}catch(e){return void i((()=>d.error(e)))}i((()=>d.next(e)))}),{injector:c,manualCleanup:!0});return c.get(r).onDestroy((()=>{a.destroy(),d.complete()})),d.asObservable()}function D(t,s){!s?.injector&&e(x);const c=s?.injector??n(o),d=new f(1),a=u((()=>{let e;try{e=t()}catch(e){return void i((()=>d.error(e)))}i((()=>d.next(e)))}),{injector:c,manualCleanup:!0});return c.get(r).onDestroy((()=>{a.destroy(),d.complete()})),d.asObservable()}function j(t,o){"undefined"!=typeof ngDevMode&&ngDevMode&&c(j,"Invoking `toSignal` causes new subscriptions every time. Consider moving `toSignal` outside of the reactive context and read the signal value where needed.");const s=!o?.manualCleanup;s&&!o?.injector&&e(j);const i=s?o?.injector?.get(r)??n(r):null,u=function(e=Object.is){return(n,r)=>1===n.kind&&1===r.kind&&e(n.value,r.value)}(o?.equal);let b;b=d(o?.requireSync?{kind:0}:{kind:1,value:o?.initialValue},{equal:u});const v=t.subscribe({next:e=>b.set({kind:1,value:e}),error:e=>{if(o?.rejectErrors)throw e;b.set({kind:2,error:e})}});if(o?.requireSync&&0===b().kind)throw new a(601,("undefined"==typeof ngDevMode||ngDevMode)&&"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");return i?.onDestroy(v.unsubscribe.bind(v)),l((()=>{const e=b();switch(e.kind){case 1:return e.value;case 2:throw e.error;case 0:throw new a(601,("undefined"==typeof ngDevMode||ngDevMode)&&"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.")}}),{equal:o?.equal})}function k(r){void 0===r&&(e(k),r=n(o));const t=r.get(b);return e=>new p((n=>{const r=t.add();let o=!1;function s(){o||(r(),o=!0)}const i=e.subscribe({next:e=>{n.next(e),s()},complete:()=>{n.complete(),s()},error:e=>{n.error(e),s()}});return i.add((()=>{n.unsubscribe(),s()})),i}))}function S(n){return n?.injector||e(S),v({...n,loader:void 0,stream:e=>{let r;const t=()=>r.unsubscribe();e.abortSignal.addEventListener("abort",t);const o=d({value:void 0});let s;const i=new Promise((e=>s=e));function u(e){o.set(e),s?.(o),s=void 0}return r=n.loader(e).subscribe({next:e=>u({value:e}),error:e=>u({error:e}),complete:()=>{s&&u({error:new Error("Resource completed before producing a value")}),e.abortSignal.removeEventListener("abort",t)}}),i}})}export{h as outputFromObservable,w as outputToObservable,k as pendingUntilEvent,S as rxResource,y as takeUntilDestroyed,x as toObservable,j as toSignal,D as ɵtoObservableMicrotask};export default null;
